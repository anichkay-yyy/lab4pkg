{"ast":null,"code":"var _jsxFileName = \"/home/anichkay/lab4pkg/src/components/Canvas.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback } from 'react';\nimport { screenToWorld, worldToScreen } from '../utils/coordinates';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst COLORS = {\n  'Пошаговый алгоритм': '#FF6B6B',\n  'Алгоритм ЦДА': '#4ECDC4',\n  'Брезенхем (линия)': '#45B7D1',\n  'Брезенхем (окружность)': '#96CEB4'\n};\nconst Canvas = ({\n  results = [],\n  currentPoints = [],\n  onPointSelect,\n  scale = 20,\n  onScaleChange,\n  showGrid = true\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const sizeRef = useRef({\n    width: 0,\n    height: 0\n  });\n  const draw = useCallback((ctx, width, height) => {\n    ctx.fillStyle = '#ffffff';\n    ctx.fillRect(0, 0, width, height);\n    ctx.save();\n    ctx.translate(width / 2, height / 2);\n    ctx.scale(scale, -scale);\n    ctx.lineWidth = Math.max(0.3 / scale, 0.05);\n    ctx.strokeStyle = '#f5f5f5';\n    ctx.fillStyle = '#000';\n    const viewSize = Math.max(width, height) / scale * 0.8;\n    const maxGridLines = 50;\n    let gridStep = Math.pow(2, Math.floor(Math.log2(Math.max(1, viewSize / maxGridLines))));\n    gridStep = Math.max(1, gridStep);\n    const gridMin = Math.floor(-viewSize / gridStep) * gridStep;\n    const gridMax = Math.ceil(viewSize / gridStep) * gridStep;\n    if (showGrid) {\n      // Основная сетка (светлая)\n      ctx.strokeStyle = '#f0f0f0';\n      ctx.lineWidth = Math.max(0.5 / scale, 0.05);\n      for (let i = gridMin; i <= gridMax; i += gridStep) {\n        ctx.beginPath();\n        ctx.moveTo(i, gridMin);\n        ctx.lineTo(i, gridMax);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(gridMin, i);\n        ctx.lineTo(gridMax, i);\n        ctx.stroke();\n      }\n\n      // Жирная сетка каждые 5 шагов\n      ctx.strokeStyle = '#d0d0d0';\n      ctx.lineWidth = Math.max(1 / scale, 0.1);\n      for (let i = gridMin; i <= gridMax; i += gridStep * 5) {\n        ctx.beginPath();\n        ctx.moveTo(i, gridMin);\n        ctx.lineTo(i, gridMax);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(gridMin, i);\n        ctx.lineTo(gridMax, i);\n        ctx.stroke();\n      }\n    }\n\n    // Оси\n    ctx.strokeStyle = '#999';\n    ctx.lineWidth = Math.max(1.5 / scale, 0.2);\n    ctx.lineCap = 'round';\n    ctx.beginPath();\n    ctx.moveTo(-viewSize, 0);\n    ctx.lineTo(viewSize, 0);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(0, -viewSize);\n    ctx.lineTo(0, viewSize);\n    ctx.stroke();\n\n    // Подписи осей (ВСЕГДА, умное расстояние)\n    ctx.fillStyle = '#333';\n    const fontSize = Math.max(11 / scale, 1);\n    ctx.font = `${fontSize}px sans-serif`;\n\n    // Вычисляем минимальное расстояние между подписями (чтобы не накладывались)\n    // Для X: ширина ~6 символов * fontSize * 1.5 запас\n    // Для Y: высота fontSize * 2.5 запас\n    const minXDistance = Math.max(fontSize * 8, gridStep * 5);\n    const minYDistance = Math.max(fontSize * 3, gridStep * 5);\n\n    // Находим оптимальный шаг для подписей\n    let labelStepX = gridStep;\n    while (labelStepX * scale < minXDistance) {\n      labelStepX *= 2;\n    }\n    let labelStepY = gridStep;\n    while (labelStepY * scale < minYDistance) {\n      labelStepY *= 2;\n    }\n    const labelOffset = Math.max(35 / scale, 3);\n\n    // X-ось: снизу, горизонтально\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n    for (let i = gridMin; i <= gridMax; i += labelStepX) {\n      if (i === 0) continue;\n      ctx.save();\n      ctx.scale(1, -1);\n      ctx.fillText(i.toString(), i, labelOffset);\n      ctx.restore();\n    }\n\n    // Y-ось: слева, горизонтально\n    ctx.textAlign = 'right';\n    ctx.textBaseline = 'middle';\n    for (let i = gridMin; i <= gridMax; i += labelStepY) {\n      if (i === 0) continue;\n      ctx.save();\n      ctx.scale(1, -1);\n      ctx.fillText(i.toString(), -labelOffset, -i);\n      ctx.restore();\n    }\n\n    // Подпись начала координат (0,0) в углу\n    ctx.textAlign = 'right';\n    ctx.textBaseline = 'top';\n    ctx.save();\n    ctx.scale(1, -1);\n    ctx.fillText('0', -labelOffset / 3, labelOffset / 3);\n    ctx.restore();\n    ctx.restore();\n\n    // Выбранные точки\n    ctx.fillStyle = '#FFD700';\n    ctx.strokeStyle = '#B8860B';\n    ctx.lineWidth = 2;\n    currentPoints.forEach(([x, y]) => {\n      const [sx, sy] = worldToScreen(x, y, width, height, scale);\n      ctx.beginPath();\n      ctx.arc(sx, sy, 10, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.stroke();\n    });\n\n    // Пиксели\n    results.forEach(({\n      points,\n      name\n    }) => {\n      const color = COLORS[name] || '#888';\n      ctx.fillStyle = color;\n      ctx.strokeStyle = color + '20';\n      points.forEach(([wx, wy]) => {\n        const [sx, sy] = worldToScreen(wx, wy, width, height, scale);\n        const pixelSize = Math.max(scale * 0.7, 1);\n        ctx.fillRect(sx - pixelSize / 2, sy - pixelSize / 2, pixelSize, pixelSize);\n        ctx.strokeRect(sx - pixelSize / 2, sy - pixelSize / 2, pixelSize, pixelSize);\n      });\n    });\n  }, [results, currentPoints, scale, showGrid]);\n  const resize = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = rect.width * dpr;\n    canvas.height = rect.height * dpr;\n    sizeRef.current = {\n      width: canvas.width,\n      height: canvas.height\n    };\n    const ctx = canvas.getContext('2d');\n    ctx.scale(dpr, dpr);\n    draw(ctx, rect.width, rect.height);\n  }, [draw]);\n  useEffect(() => {\n    window.addEventListener('resize', resize);\n    resize();\n    return () => window.removeEventListener('resize', resize);\n  }, [resize]);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    const rect = canvas.getBoundingClientRect();\n    draw(ctx, rect.width, rect.height);\n  }, [draw]);\n  const handleWheel = useCallback(e => {\n    e.preventDefault();\n    const delta = e.deltaY > 0 ? 0.9 : 1.1;\n    const newScale = Math.max(5, Math.min(100, scale * delta));\n    onScaleChange(newScale);\n  }, [scale, onScaleChange]);\n  const handleClick = useCallback(e => {\n    const canvas = canvasRef.current;\n    if (!canvas || !onPointSelect) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    const width = rect.width;\n    const height = rect.height;\n    const [wx, wy] = screenToWorld(x, y, width, height, scale);\n    onPointSelect(Math.round(wx), Math.round(wy));\n  }, [onPointSelect, scale]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    className: \"canvas\",\n    onWheel: handleWheel,\n    onClick: handleClick,\n    style: {\n      cursor: 'crosshair'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 211,\n    columnNumber: 5\n  }, this);\n};\n_s(Canvas, \"2cP6Io88FIwod+4C8PyWm0zV31s=\");\n_c = Canvas;\nexport default Canvas;\nvar _c;\n$RefreshReg$(_c, \"Canvas\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","screenToWorld","worldToScreen","jsxDEV","_jsxDEV","COLORS","Canvas","results","currentPoints","onPointSelect","scale","onScaleChange","showGrid","_s","canvasRef","sizeRef","width","height","draw","ctx","fillStyle","fillRect","save","translate","lineWidth","Math","max","strokeStyle","viewSize","maxGridLines","gridStep","pow","floor","log2","gridMin","gridMax","ceil","i","beginPath","moveTo","lineTo","stroke","lineCap","fontSize","font","minXDistance","minYDistance","labelStepX","labelStepY","labelOffset","textAlign","textBaseline","fillText","toString","restore","forEach","x","y","sx","sy","arc","PI","fill","points","name","color","wx","wy","pixelSize","strokeRect","resize","canvas","current","rect","getBoundingClientRect","dpr","window","devicePixelRatio","getContext","addEventListener","removeEventListener","handleWheel","e","preventDefault","delta","deltaY","newScale","min","handleClick","clientX","left","clientY","top","round","ref","className","onWheel","onClick","style","cursor","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/anichkay/lab4pkg/src/components/Canvas.js"],"sourcesContent":["import React, { useRef, useEffect, useCallback } from 'react';\nimport { screenToWorld, worldToScreen } from '../utils/coordinates';\n\nconst COLORS = {\n  'Пошаговый алгоритм': '#FF6B6B',\n  'Алгоритм ЦДА': '#4ECDC4',\n  'Брезенхем (линия)': '#45B7D1',\n  'Брезенхем (окружность)': '#96CEB4',\n};\n\nconst Canvas = ({ \n  results = [], \n  currentPoints = [], \n  onPointSelect, \n  scale = 20,\n  onScaleChange,\n  showGrid = true \n}) => {\n  const canvasRef = useRef(null);\n  const sizeRef = useRef({ width: 0, height: 0 });\n\n  const draw = useCallback((ctx, width, height) => {\n    ctx.fillStyle = '#ffffff';\n    ctx.fillRect(0, 0, width, height);\n    ctx.save();\n    ctx.translate(width / 2, height / 2);\n    ctx.scale(scale, -scale);\n    ctx.lineWidth = Math.max(0.3 / scale, 0.05);\n    ctx.strokeStyle = '#f5f5f5';\n    ctx.fillStyle = '#000';\n\n    const viewSize = Math.max(width, height) / scale * 0.8;\n    const maxGridLines = 50;\n    let gridStep = Math.pow(2, Math.floor(Math.log2(Math.max(1, viewSize / maxGridLines))));\n    gridStep = Math.max(1, gridStep);\n    const gridMin = Math.floor(-viewSize / gridStep) * gridStep;\n    const gridMax = Math.ceil(viewSize / gridStep) * gridStep;\n\n    if (showGrid) {\n      // Основная сетка (светлая)\n      ctx.strokeStyle = '#f0f0f0';\n      ctx.lineWidth = Math.max(0.5 / scale, 0.05);\n      for (let i = gridMin; i <= gridMax; i += gridStep) {\n        ctx.beginPath();\n        ctx.moveTo(i, gridMin);\n        ctx.lineTo(i, gridMax);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(gridMin, i);\n        ctx.lineTo(gridMax, i);\n        ctx.stroke();\n      }\n      \n      // Жирная сетка каждые 5 шагов\n      ctx.strokeStyle = '#d0d0d0';\n      ctx.lineWidth = Math.max(1 / scale, 0.1);\n      for (let i = gridMin; i <= gridMax; i += gridStep * 5) {\n        ctx.beginPath();\n        ctx.moveTo(i, gridMin);\n        ctx.lineTo(i, gridMax);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(gridMin, i);\n        ctx.lineTo(gridMax, i);\n        ctx.stroke();\n      }\n    }\n\n    // Оси\n    ctx.strokeStyle = '#999';\n    ctx.lineWidth = Math.max(1.5 / scale, 0.2);\n    ctx.lineCap = 'round';\n    ctx.beginPath();\n    ctx.moveTo(-viewSize, 0);\n    ctx.lineTo(viewSize, 0);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(0, -viewSize);\n    ctx.lineTo(0, viewSize);\n    ctx.stroke();\n\n    // Подписи осей (ВСЕГДА, умное расстояние)\n    ctx.fillStyle = '#333';\n    const fontSize = Math.max(11 / scale, 1);\n    ctx.font = `${fontSize}px sans-serif`;\n    \n    // Вычисляем минимальное расстояние между подписями (чтобы не накладывались)\n    // Для X: ширина ~6 символов * fontSize * 1.5 запас\n    // Для Y: высота fontSize * 2.5 запас\n    const minXDistance = Math.max(fontSize * 8, gridStep * 5);\n    const minYDistance = Math.max(fontSize * 3, gridStep * 5);\n    \n    // Находим оптимальный шаг для подписей\n    let labelStepX = gridStep;\n    while (labelStepX * scale < minXDistance) {\n      labelStepX *= 2;\n    }\n    \n    let labelStepY = gridStep;\n    while (labelStepY * scale < minYDistance) {\n      labelStepY *= 2;\n    }\n    \n    const labelOffset = Math.max(35 / scale, 3);\n\n    // X-ось: снизу, горизонтально\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n    for (let i = gridMin; i <= gridMax; i += labelStepX) {\n      if (i === 0) continue;\n      ctx.save();\n      ctx.scale(1, -1);\n      ctx.fillText(i.toString(), i, labelOffset);\n      ctx.restore();\n    }\n\n    // Y-ось: слева, горизонтально\n    ctx.textAlign = 'right';\n    ctx.textBaseline = 'middle';\n    for (let i = gridMin; i <= gridMax; i += labelStepY) {\n      if (i === 0) continue;\n      ctx.save();\n      ctx.scale(1, -1);\n      ctx.fillText(i.toString(), -labelOffset, -i);\n      ctx.restore();\n    }\n    \n    // Подпись начала координат (0,0) в углу\n    ctx.textAlign = 'right';\n    ctx.textBaseline = 'top';\n    ctx.save();\n    ctx.scale(1, -1);\n    ctx.fillText('0', -labelOffset / 3, labelOffset / 3);\n    ctx.restore();\n\n    ctx.restore();\n\n    // Выбранные точки\n    ctx.fillStyle = '#FFD700';\n    ctx.strokeStyle = '#B8860B';\n    ctx.lineWidth = 2;\n    currentPoints.forEach(([x, y]) => {\n      const [sx, sy] = worldToScreen(x, y, width, height, scale);\n      ctx.beginPath();\n      ctx.arc(sx, sy, 10, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.stroke();\n    });\n\n    // Пиксели\n    results.forEach(({ points, name }) => {\n      const color = COLORS[name] || '#888';\n      ctx.fillStyle = color;\n      ctx.strokeStyle = color + '20';\n      points.forEach(([wx, wy]) => {\n        const [sx, sy] = worldToScreen(wx, wy, width, height, scale);\n        const pixelSize = Math.max(scale * 0.7, 1);\n        ctx.fillRect(sx - pixelSize/2, sy - pixelSize/2, pixelSize, pixelSize);\n        ctx.strokeRect(sx - pixelSize/2, sy - pixelSize/2, pixelSize, pixelSize);\n      });\n    });\n  }, [results, currentPoints, scale, showGrid]);\n\n  const resize = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = rect.width * dpr;\n    canvas.height = rect.height * dpr;\n    sizeRef.current = { width: canvas.width, height: canvas.height };\n    const ctx = canvas.getContext('2d');\n    ctx.scale(dpr, dpr);\n    draw(ctx, rect.width, rect.height);\n  }, [draw]);\n\n  useEffect(() => {\n    window.addEventListener('resize', resize);\n    resize();\n    return () => window.removeEventListener('resize', resize);\n  }, [resize]);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    const rect = canvas.getBoundingClientRect();\n    draw(ctx, rect.width, rect.height);\n  }, [draw]);\n\n  const handleWheel = useCallback((e) => {\n    e.preventDefault();\n    const delta = e.deltaY > 0 ? 0.9 : 1.1;\n    const newScale = Math.max(5, Math.min(100, scale * delta));\n    onScaleChange(newScale);\n  }, [scale, onScaleChange]);\n\n  const handleClick = useCallback((e) => {\n    const canvas = canvasRef.current;\n    if (!canvas || !onPointSelect) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    const width = rect.width;\n    const height = rect.height;\n    const [wx, wy] = screenToWorld(x, y, width, height, scale);\n    onPointSelect(Math.round(wx), Math.round(wy));\n  }, [onPointSelect, scale]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className=\"canvas\"\n      onWheel={handleWheel}\n      onClick={handleClick}\n      style={{ cursor: 'crosshair' }}\n    />\n  );\n};\n\nexport default Canvas;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}